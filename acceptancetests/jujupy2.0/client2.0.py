from contextlib import contextmanager
import json
import logging
import subprocess
import sys

from utility import (
    dump_all_logs,
    LoggedException
)
"""
The shit we really care about:
    Hook into existing controller OR bootstrap our own.
        Init a client object -> client.bootstrap(name, default model, config)
            bootstrap sets controller name to BS name
            adds a model with default model name & config
            waits for finish - SEE TIMEOUTS BELOW
        Init a client object -> client.connect_to_existing()
            connect_to_existing sets controller name to current controller
            in env and pulls models, active model
    tracking models/controllers:
        client object, which has model objects:
            client:
                stores controller name
                stores its models
                has juju() method:
                    run on current model?
                    juju(command, (args,))
                    ^ calls _juju(target, command, args)
            models:

    running juju commands via the cli:
        need a cli wrapper in the form of client.juju('command', (args,))
    tracking state of machines?
        how do we do this now?
    logs
    reading/parsing status into something machine readable

    timeouts on the above:
        wait_for_state(state)
        bootstrapping
        depoying
        etc.
        This is the hard bit


"""

log = logging.getLogger('jujupy')


class NoActiveModel(Exception):
    """No active Model Selected"""


class JujuCommandError(Exception):
    """Error in called Juju command."""


class TestingContext:
    """Context handler for testing. Will create a juju client object for use
    in testing then gather all logs and tear down once that test is complete.


    Generates a juju environemnt if none exists
        argument flags:
            env -> substrate
            logs -> logging directory
            temp_env_name -> <test>-<timestamp> as before
            existng -> bootstrapped controller

        if not existing:
            bootstrap a controller on <env> with <temp_env_name> as default-model
            return a client object pointing to that controller
        else:
            validate the controller exists
            add a model with <temp_env_name>
            return a client object pointing to that controller/model

    Grabs logs and tears down that environment


    """
    def __init__(self, args):
        self.environment = args.env

    @contextmanager
    def texting_context(self, args):
        try:
            client = self.get_client(args)
            yield client
        except LoggedException:
            sys.exit(1)
        finally:
            client.dump_logs()

    def get_client(self, args):
        if args.existing:
            return self.existing_context(args)
        else:
            return self.booted_context(args)

    def booted_context(self, args):
        """Bootstrap a controller and return a JujuClient object.

        Bootstraps the controller using specified args. Returns a JujuClient
        object pointing to that controller.
        """
        pass

    def existing_context(self, args):
        """Return a JujuClient object that points to an existing controller.

        Collects credentials from the environment and validates the controller
        specified by args.existing exists, then creates a JujuClient object
        for that controller and adds args.temp_env_name model to that
        controller.
        """
        pass


class JujuClient:

    """Pointer to a juju controller for use in testing.

    This class represents a single juju controller for use in testing. This
    controller can either be generated by testing environemnt via bootstrap
    or represent an existing controller, ideally it makes no difference.

    :ivar name: Name of the controller, existing or bootstrapped
    :ivar args:
    """

    # Calls to Juju where we pass '--format json' by default
    formatted_calls = [
        'status',
        'models',
        'users',
        'controllers',
        ]

    def __init__(self, name, args):
        self.name = name
        self.default_model = args.temp_env_name
        self.models = set(self.default_model)
        self.active_model = self._get_active_model()
        self.keep_env = True

    def juju(self, command, args, get_output=True, controller=False,
             model=None, format_json=True):
        """Runs a command against the target or current juju model"""
        if controller:
            args = ('-m', '{}:controller'.format(self.name)) + args
        else:
            args = ('-m', '{}:{}'.format(
                self.name, model or self.active_model))
        if format_json and command in self.formatted_calls:
            args = args + ('--format', 'json')
        if get_output:
            call = subprocess.check_output
        else:
            call = subprocess.call
        try:
            log.info('Juju call: {} {}'.format(command, ' '.join(args)))
            out = call('juju', command, args).decode('UTF-8')
            if format_json:
                return json.loads(out)
            else:
                return out
        except subprocess.CalledProcessError as e:
            log.error(
                'Juju call "{} {}" failed'.format(command, ' '.join(args)))
            raise JujuCommandError(e)

    def add_model(self, model):
        new_model = JujuModel(model)
        self.juju('add-model', (model,))
        self.models.add(new_model)
        self.active_model = new_model

    def switch_model(self, target_model):
        """Switches current model to target_model

        :param target_model: JujuModel object
        """
        self.juju('switch', (target_model.name))
        self.active_model = target_model

    def deploy(self, charm, num=1, to=None):
        """Deploy a charm to the current model"""
        args = (charm,)
        if num:
            args += ('-n', num)
        if to:
            args += ('--to', to)
        self.juju('deploy', args)

    def status(self, controller=False, model=None):
        """Returns status for the target or active model."""
        self.juju('status', controller=controller, model=model)

    def cleanup(self):
        """Cleans up the environment by collecting logs and tearing down.

        Collect logs for the default model and any added models
        Collect controller logs

        If not keep-env:
            If existing: tear down default model and any added models
            Else tear down controller
        """
        pass

    def _dump_logs(self, model):
        """Contact machines, controller & pull logs

        Pulls status, gets machines. SCP /var/log/whatever off each machine
        tar up the logs by machine
        SCP /var/log/whatever off controller machines
        """
        controller_machines = self._get_controller_machines().keys()
        for machine in controller_machines:
            dump_all_logs(machine, controller=True)
        model_machines = self._get_model_machines(model).keys()
        for machine in model_machines:
            dump_all_logs(machine, model=True)

    def _generate_models(self):
        """Generates model objects for each model in the existing environment
        """
        active_models = self._get_current_models()
        for model in active_models.keys():
            yield JujuModel(model)

    def _get_active_model(self):
        """Gets the active model for the current Juju controller
        """
        models = self._get_current_models()
        try:
            return models['current-model']
        except KeyError:
            raise NoActiveModel('No model currently selected')

    def _get_current_models(self):
        """Gets the current models when controller object was intialized

        :return: JSON blob of models
        """
        return self.juju('models')

    def _get_controller_machines(self):
        """Gets the machines from the controller model"""
        return self.juju('models', controller=True)['machines']

    def _get_model_machines(self, model):
        """Gets the machines from a model"""
        return self.juju('status', model=model)['machines']


class JujuModel:

    def __init__(self, name, config=None):
        self.name = name
        self.config = config
