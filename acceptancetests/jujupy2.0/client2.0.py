from contextlib import contextmanager
import json
import logging
import os
import subprocess
import sys
import yaml

from utility import (
    dump_all_logs,
    get_bootstrap_args,
    LoggedException,
    State,
    GroupReporter,
    until_timeout,
    StatusNotMet
)
"""
The shit we really care about:
    Hook into existing controller OR bootstrap our own.
        Init a client object -> client.bootstrap(name, default model, config)
            bootstrap sets controller name to BS name
            adds a model with default model name & config
            waits for finish - SEE TIMEOUTS BELOW
        Init a client object -> client.connect_to_existing()
            connect_to_existing sets controller name to current controller
            in env and pulls models, active model
    tracking models/controllers:
        client object, which has model objects:
            client:
                stores controller name
                stores its models
                has juju() method:
                    run on current model?
                    juju(command, (args,))
                    ^ calls _juju(target, command, args)
            models:

    running juju commands via the cli:
        need a cli wrapper in the form of client.juju('command', (args,))
    tracking state of machines?
        how do we do this now?
    logs
    reading/parsing status into something machine readable

    timeouts on the above:
        wait_for_state(state)
        bootstrapping
        depoying
        etc.
        This is the hard bit


"""

log = logging.getLogger('jujupy')


class NoActiveModel(Exception):
    """No active Model Selected."""


class JujuCommandError(Exception):
    """Error in called Juju command."""


class ControllerNotFound(Exception):
    """Target controller not found in environemnt."""


class TestingContext:
    """Context handler for testing. Creates a JujuClient object for use
    in testing then gather all logs and tear down once that test is complete.


    with TestingContext.testing_context(args) as test_client:
        do_some_test(test_client)

    Generates a juju environemnt if none exists
        argument flags:
            env -> substrate
            logs -> logging directory
            temp_env_name -> <test>-<timestamp> as before
            existng -> bootstrapped controller

        if not existing:
            bootstrap a controller on <env> with <temp_env_name> as default-model
            return a client object pointing to that controller
        else:
            validate the controller exists
            add a model with <temp_env_name>
            return a client object pointing to that controller/model

    Grabs logs and tears down that environment
    """
    def __init__(self, args):
        self.environment = args.env

    @contextmanager
    def testing_context(self, args):
        try:
            client = self.get_client(args)
            yield client
        except LoggedException:
            sys.exit(1)
        finally:
            client.dump_logs()
            if not args.keep_env:
                client.cleanup()

    def get_client(self, args):
        if args.existing:
            return self.existing_context(args)
        else:
            return self.booted_context(args)

    def booted_context(self, args):
        """Bootstrap a controller and return a JujuClient object.

        Bootstraps the controller using specified args. Returns a JujuClient
        object pointing to that controller.
        """
        client = JujuClient(args.temp_env_name, args)
        client.bootstrap(args)
        return client

    def existing_context(self, args):
        """Return a JujuClient object that points to an existing controller.

        Collects credentials from the environment and validates the controller
        specified by args.existing exists, then creates a JujuClient object
        for that controller and adds args.temp_env_name model to that
        controller.
        """
        client = JujuClient(args.temp_env_name, args)
        client._verify_existing_controller(args.existing)
        client.add_model(args.temp_env_name)
        return client


class JujuClient:

    """Pointer to a juju controller for use in testing.

    This class represents a single juju controller for use in testing. This
    controller can either be generated by testing environemnt via bootstrap
    or represent an existing controller, ideally it makes no difference.

    :ivar name: Name of the controller, existing or bootstrapped
    :ivar args:
    """

    # Calls to Juju where we pass '--format json' by default
    formatted_calls = [
        'status',
        'models',
        'users',
        'controllers',
        ]

    def __init__(self, name, args):
        self.name = name
        self.substrate = args.env
        self.region = None
        self.default_model = args.temp_env_name
        self.models = set(self.default_model)
        self.active_model = self._get_active_model()
        if args.existing is not None:
            self.existing = True

    def juju(self, command, args=None, get_output=True, controller=False,
             model=None, format_json=True):
        """Runs a command against the target or current juju model"""
        if args is None:
            args = ()
        if controller:
            args = ('-m', '{}:controller'.format(self.name)) + args
        else:
            args = ('-m', '{}:{}'.format(
                self.name, model or self.active_model))
        if format_json and command in self.formatted_calls:
            args = args + ('--format', 'json')
        if get_output:
            call = subprocess.check_output
        else:
            call = subprocess.call
        try:
            log.info('Juju call: {} {}'.format(command, ' '.join(args)))
            out = call('juju', command, args).decode('UTF-8')
            if format_json:
                return json.loads(out)
            else:
                return out
        except subprocess.CalledProcessError as e:
            log.error(
                'Juju call "{} {}" failed'.format(command, ' '.join(args)))
            raise JujuCommandError(e)

    def add_model(self, model):
        new_model = JujuModel(model)
        self.juju('add-model', (model,))
        self.models.add(new_model)
        self.active_model = new_model

    def switch_model(self, target_model):
        """Switches current model to target_model

        :param target_model: JujuModel object
        """
        self.juju('switch', (target_model.name))
        self.active_model = target_model

    def deploy(self, charm, num=1, to=None):
        """Deploy a charm to the current model"""
        args = (charm,)
        if num:
            args += ('-n', num)
        if to:
            args += ('--to', to)
        self.juju('deploy', args)

    def status(self, controller=False, model=None):
        """Returns status for the target or active model."""
        self.juju('status', controller=controller, model=model)

    def bootstrap(self, args):
        """Bootstraps the client object with the given args"""
        bs_args = get_bootstrap_args(args)
        subprocess.call(['juju', 'boostrap'].extend(bs_args))
        reporter = GroupReporter(sys.stdout, 'started')
        self.wait_for_state(reporter, State.started)

    def cleanup(self):
        """Cleans up the environment by tearing down the models or controller.
        """
        if self.existing:
            for model in self.models:
                self.destroy-model(model)
        else:
            self.juju('destroy-controller', (self.name, '-y'))

    def wait_for_state(self, reporter, state, timeout=1800,
                       exc_type=StatusNotMet):
        """Wait for target state in the client model.

        Take a state object defining the goal state
        Object checks status/whatever and evaluates state, returning state data
        until the target state is reached
        When state is reached, it returns None
        If timeout is reached before the state returns None, raise.

        """
        status = None
        try:
            for _ in until_timeout(timeout):
                status = self.status()
                states = state(status)
                if states is None:
                    break
                else:
                    reporter.update(states)
            else:
                if status is not None:
                    status.raise_highest_error(
                        ignore_recoverable=False)
                raise exc_type(self.env.environment, status)
        finally:
            reporter.finish()
        return status

    def _dump_logs(self, model):
        """Contact machines, controller & pull logs

        Pulls status, gets machines. SCP /var/log/whatever off each machine
        tar up the logs by machine
        SCP /var/log/whatever off controller machines
        """
        controller_machines = self._get_controller_machines().keys()
        for machine in controller_machines:
            dump_all_logs(machine, controller=True)
        model_machines = self._get_model_machines(model).keys()
        for machine in model_machines:
            dump_all_logs(machine, model=True)

    def _generate_models(self):
        """Generates model objects for each model in the existing environment
        """
        active_models = self._get_current_models()
        for model in active_models.keys():
            yield JujuModel(model)

    def _get_active_model(self):
        """Gets the active model for the current Juju controller
        """
        models = self._get_current_models()
        try:
            return models['current-model']
        except KeyError:
            raise NoActiveModel('No model currently selected')

    def _get_current_models(self):
        """Gets the current models when controller object was intialized

        :return: JSON blob of models
        """
        return self.juju('models')

    def _get_controller_machines(self):
        """Gets the machines from the controller model"""
        return self.juju('models', controller=True)['machines']

    def _get_model_machines(self, model):
        """Gets the machines from a model"""
        return self.juju('status', model=model)['machines']

    def _verify_existing_controller(target):
        """Verify the target controller exists in the environment."""
        home = os.path.expanduser("~")
        # JUJU DATA
        if os.environ['JUJU_DATA']:
            controllers = yaml.loads(open(os.path.join((
                os.environ['JUJU_DATA'], 'controllers.yaml'))))
        else:
            try:
                controllers = yaml.loads(open(os.path.join(
                    home, '.local/share/juju/controllers.yaml')))
            except OSError:
                controllers = yaml.loads(open(os.path.join(
                    home, '.juju/controllers.yaml')))
        if target not in controllers['controllers'].keys():
            raise ControllerNotFound(
                '{} not found in local environment.'.format(target))


class JujuModel:

    def __init__(self, name, config=None):
        self.name = name
        self.config = config
